# -----------------------------------------------------------------------------
# Functions for downstream analyses after epiAneufinder main run
# -----------------------------------------------------------------------------

#' Split cells into different subclones based on hierarchical clustering of the CNV profiles
#' 
#' @param res_table Result data frame generated by the epiAneufinder main function
#' @param tree_depth Depth at which the dendogram should be cut
#' @param plot_tree Boolean value whether the cutted dendogram should be visualized
#' @param plot_path Path under which the dendogram is saved as a png (only for plot_tree=TRUE)
#' @param plot_width Width of the png (only for plot_tree=TRUE)
#' @param plot_height Height of the png (only for plot_tree=TRUE)
#' @import data.table
#' @import ggplot2
#' @import cowplot
#' @import gridExtra
#' @export
split_subclones<-function(res_table,tree_depth,plot_tree=TRUE,
                          plot_path="dendogram_clustering.pdf",
                          plot_width=4,
                          plot_height=3){
  
  #Reformat result table
  res_table<-as.data.table(res_table)
  somies.dt <- res_table[,-c("start","end")]
  somies.dt$rn <- 1:nrow(somies.dt)
  #Extract all cell columns (column starts with cell- or cell.)
  counts_t <- t(somies.dt[ ,.SD, .SDcols=patterns('cell.')])
  
  #Calculate hierarchical clustering
  dist_matrix <- dist(counts_t)
  dist_matrix[is.na(dist_matrix)] <- 0
  hc_counts <- hclust(dist_matrix, method = "ward.D")
  
  #Split at a certain depth
  cl_members<-cutree(hc_counts,k=tree_depth)
  cl_members_df<-data.frame(cell=names(cl_members),
                            subclone=cl_members)
    
  #Create a plot of the subclones
  if(plot_tree){
    pdf(plot_path, width = plot_width, height = plot_height)
    plot(x = hc_counts,labels= FALSE,hang=-1) 
    rect.hclust(tree = hc_counts, k = tree_depth,border=1:tree_depth)
    dev.off()
  }

  #Return the subclones
  return(cl_members_df)
}

#' Recreate the karyogram plot - optional with an annotation side bar
#' 
#' @param res_table Result data frame generated by the epiAneufinder main function
#' @param plot_path Path under which the karyogram is saved
#' @param annot_dt Optional an annotation data frame with the columns cell (=cell barcode) 
#' and annot (= categories or numerical values for the annotation side bar). Set value to NULL
#' if no side bar should be plotted.
#' @param title_karyo Plot title for the karyogram
#' @import data.table
#' @import ggplot2
#' @import ggdendro
#' @import cowplot
#' @export
plot_karyo_annotated <- function(res_table, plot_path, snp_csv_path = NULL, annot_dt = NULL, 
                                 title_karyo = "", dice_tree_path = NULL) {

  # Reformat somy dataframe
  res_table <- as.data.table(res_table)
  somies.dt <- res_table[, -c("start", "end")]
  somies.dt$rn <- 1:nrow(somies.dt)
  somies_melted <- melt(somies.dt, id.vars = c('rn', 'seq'))
  somies_melted$value <- as.factor(paste0(somies_melted$value, '-somy'))

  # Sort the karyogram chromosomes correctly
  somies_melted$seq <- factor(somies_melted$seq, levels = unique(res_table$seq))

  # Load and plot DICE phylogenetic tree
  if (!is.null(dice_tree_path)) {
    library(ape)
    library(ggtree)
    library(viridis)

    # Read the DICE tree from the Newick file
    dice_tree <- read.tree(dice_tree_path)
    ggtree_plot <- ggtree(dice_tree) + 
                  theme_tree() +
                  labs(title="DICE Phylogenetic Tree")

    # Reorder cells in karyogram based on DICE tree tip labels
    somies_melted$variable <- factor(somies_melted$variable,
                                    levels = dice_tree$tip.label)

    if (!is.null(snp_csv_path)) {
      # Load SNP data from alleles assay
      allele_data <- fread(snp_csv_path, header = TRUE)
      
      # Ensure row names (SNPs) are properly set
      rownames(allele_data) <- allele_data[[1]]
      allele_data <- allele_data[, -1, with = FALSE]
      
      # Reorder allele data columns based on DICE tree tip labels (barcodes)
      ordered_barcodes <- dice_tree$tip.label
      
      # Ensure barcodes in DICE match those in SNP data
      if (!all(ordered_barcodes %in% colnames(allele_data))) {
        stop("Barcodes in DICE tree do not match those in the SNP data.")
      }

      allele_data <- allele_data[, ..ordered_barcodes]

      allele_data_dt <- as.data.table(as.matrix(allele_data), keep.rownames = "SNP")
      allele_data_melted <- melt(allele_data_dt, id.vars = "SNP", variable.name = "Barcode", value.name = "Frequency")

      # Create SNP heatmap
      snp_heatmap <- ggplot(allele_data_melted, aes(x = Barcode, y = SNP, fill = Frequency)) +
        geom_tile() +
        scale_fill_viridis(option = "cividis", name = "Allele Frequency") +
        labs(x = "Cells (Barcodes)", y = "SNPs", title = "SNP Profile") +
        theme_minimal() +
        theme(axis.text.x = element_blank(),
              axis.ticks.x = element_blank())
      
    } else if (!is.null(annot_dt)) {
      # Reverse back code - in case no Seurat object is provided
      # Check if annot_dt is a data frame with at least two columns
      if (!is.data.frame(annot_dt) || ncol(annot_dt) < 2) {
        stop("Error: Annotation data must be a data frame with at least two columns.")
      }

      # Dynamically map columns to standard names
      colnames(annot_dt) <- c("cell", "annot")

      # Convert numeric annotations to factors for categorical mapping
      annot_dt$annot <- as.factor(annot_dt$annot)

      # Reorder annotations based on DICE tree tip labels
      annot_dt$cell <- factor(as.character(annot_dt$cell),
                              levels = dice_tree$tip.label)

    # Generate a dynamic color palette for annotations
      unique_annotations <- levels(annot_dt$annot)
      num_categories <- length(unique_annotations)
      annotation_colors <- scales::hue_pal()(num_categories)
      names(annotation_colors) <- unique_annotations

      annot_dt$type <- "Annotation"

      ggannot <- ggplot(annot_dt, aes(x=cell, y=1, fill=annot)) +
        geom_tile() +
        coord_flip() +
        facet_grid(~type, scales='free', space='free') +
        labs(title="", fill="Annotation") +
        scale_fill_manual(values=annotation_colors) + 
        theme(legend.title=element_text(size=16),
              legend.text=element_text(size=16),
              plot.title=element_text(size=18)) +
        guides(fill=guide_legend(nrow=1, byrow=TRUE))

      gglegend <- cowplot::get_legend(ggannot)

      ggannot <- ggannot +
        ylab("") +
        theme(axis.title.y=element_blank(),
              axis.ticks=element_blank(),
              axis.text=element_blank(),
              legend.position="none")
    }
  # Define somy colors
  somycolours <- c(`0-somy` = "darkorchid3",
                  `1-somy` = "springgreen2",
                  `2-somy` = "red3")

# Create karyogram heatmap
    ggsomy <- ggplot(somies_melted, aes(x = rn, y = variable, fill = value)) + 
      geom_tile() +
      facet_grid(cols = vars(seq), scales = 'free_x', space = 'free') +
      labs(x = "Position in chromosome", fill = 'Somy', title = title_karyo) +
      scale_fill_manual(values = somycolours) +
      theme(axis.ticks.x = element_blank(),
            axis.text.x = element_blank(),
            legend.position = 'none',
            plot.title = element_text(size=18),
            strip.text.x = element_text(size=12),
            axis.title.y=element_blank(),
            axis.text.y=element_blank())

    if (!is.null(seurat_object_path)) {
      # Combine DICE tree, karyogram, and SNP heatmap
      combiplot <- cowplot::plot_grid(
        ggtree_plot,
        ggsomy,
        snp_heatmap,
        ncol=3,
        rel_widths=c(0.2, 0.4, 0.4),
        align='h'
      )
    } else {
      # Combine DICE tree and karyogram with annotations
      combiplot <- cowplot::plot_grid(
        ggtree_plot,
        ggsomy,
        ggannot,
        ncol=3,
        rel_widths=c(0.1,1,0.03), 
        axis='b', align='hw'
      )

      combiplot <- cowplot::plot_grid(combiplot, gglegend,
                                      ncol=1,
                                      rel_heights=c(1,0.05))
    }

    # Save combined plot
    ggsave(plot_path, combiplot, width=36, height=20, units="in")

  } else {
    stop("DICE tree path must be provided to replace the original hierarchical clustering.")
  }
}


#' Split cells into different subclones based on hierarchical clustering of the CNV profiles
#' 
#' @param outdir Directory created by the epiAneufinder main function with required
#' files count_summary.rds, counts_gc_corrected.rds and and cnv_calls.rds
#' @param threshold_blacklist_bins Blacklist a bin if more than the given ratio of cells have zero reads in the bin. Default: 0.85
#' @param selected_cells Either a character vector with barcodes of cells to visualize or an integer number to visualize
#' a random subset of this size
#' @import data.table
#' @import SummarizedExperiment
#' @import ggplot2
#' @import gridExtra
#' @export
plot_single_cell_profile<-function(outdir,threshold_blacklist_bins=0.85,
                                  selected_cells=10,
                                  plot_path="individual_tracks.pdf",
                                  plot_width=25,
                                  plot_height=15){
  
  #Load the raw count matrix to get region information
  counts <- readRDS(file.path(outdir,"count_summary.rds"))
  peaks <- as.data.table(assays(counts)$counts)
  colnames(peaks) <- paste0('cell-', colnames(peaks))
  rowinfo <- as.data.table(rowRanges(counts))
  peaks <- cbind(rowinfo, peaks)
  
  #Load the GC corrected counts
  corrected_counts <- readRDS(file.path(outdir,"counts_gc_corrected.rds"))
  peaks <- cbind(rowinfo, corrected_counts)
  
  #Repeat the filtering of 
  zeroes_per_bin <- peaks[, rowSums(.SD==0), .SDcols = patterns("cell-")]
  ncells <- length(grep("cell-", colnames(peaks)))
  peaks <- peaks[zeroes_per_bin<(threshold_blacklist_bins*ncells)]
  
  #Get the CNV predictions
  somies_ad <- readRDS(file.path(outdir,"cnv_calls.rds"))
  somies.dt <- as.data.table(somies_ad)
  
  #Select a random subset of cells in case the parameter is numeric
  if(is.numeric(selected_cells)){
    set.seed(123)
    randomcells<- sample(x=names(somies.dt), size=selected_cells)
  } else {
    if(! all(selected_cells %in% names(somies.dt))){
      stop(paste(selected_cells,"not found in the dataset!"))
    }
    randomcells<-selected_cells
  }

  singlecellplot <- list()
  for(i1 in randomcells){
    plot.dt <- peaks[, .(chr=seqnames, counts=get(i1))]
    plot.dt$somy <- paste0(somies_ad[[i1]], '-somy')
    plot.dt <- plot.dt[which(plot.dt$counts < quantile(plot.dt$counts, 0.999) &
                               plot.dt$counts > quantile(plot.dt$counts, 0.01))]
    plot.dt$rn <- as.numeric(rownames(plot.dt))
    plot.dt$chr <- gsub("chr","", plot.dt$chr)
    plot.dt$chr <- factor(plot.dt$chr, levels = c(1:22))
    titletext <- paste0(i1, " : Library size - ", sum(plot.dt$counts))
    somycolours <- c(`0-somy` = "darkorchid3",
                     `1-somy` = "springgreen2",
                     `2-somy` = "red3")
                                      
    numwindows <- as.data.frame(table(plot.dt$somy))
    colnames(numwindows) <- c("State", "Number of bins")
    numwindows$State <- gsub("0-somy","loss", numwindows$State)
    numwindows$State <- gsub("1-somy","normal", numwindows$State)
    numwindows$State <- gsub("2-somy","gain", numwindows$State)
    
    libsize <- as.data.frame(sum(plot.dt$counts))
    colnames(libsize) <- c("Total fragments")
    
    profileplot <- ggplot(plot.dt, aes(x=rn, y=counts)) + geom_point(alpha=0.2) +
      geom_line(aes(y=zoo::rollapply(counts, 200, mean, fill=NA)), color='red', size=1) +
      facet_grid(cols=vars(chr), scales = "free_x", space = "free_x") +
      labs(y="Counts") +
      theme(axis.ticks.x = element_blank(),
            axis.text.x = element_blank(),
            axis.title.x = element_blank(),
            panel.grid.major = element_blank(),
            panel.background = element_blank(),
            legend.position = 'none')
    
    somyplot <- ggplot(plot.dt, aes(x=rn, y=counts)) + geom_point(alpha=0.2, aes(color=somy)) +
      facet_grid(cols=vars(chr), scales = "free_x", space = "free_x") +
      labs(y="Counts") +
      scale_color_manual(labels = c("loss", "normal", "gain"), values=somycolours) +
      theme(axis.ticks.x = element_blank(),
            axis.text.x = element_blank(),
            axis.title.x = element_blank(),
            panel.grid.major = element_blank(),
            panel.background = element_blank(),
            legend.position = 'none')
    somydensity <- ggplot(plot.dt, aes(counts, fill=somy, colour=somy)) +
      geom_density(alpha=0.7) +
      scale_color_manual(labels = c("loss","normal","gain"), values=somycolours) +
      scale_fill_manual(labels = c("loss","normal","gain"), values=somycolours) +
      labs(x="Counts per bin", y="Density", title = titletext) +
      theme(panel.grid.major = element_blank(),
            panel.background = element_blank(),
            legend.key.size = unit(1, 'cm'),
            legend.text = element_text(size = 14))
    
    libsizeplot <- ggplot() + annotation_custom(tableGrob(libsize, rows=NULL)) +
      theme(panel.grid.major = element_blank(),
            panel.background = element_blank(),
            legend.key.size = unit(1, 'cm'),
            legend.text = element_text(size = 14))
    
    tableplot <- ggplot() + annotation_custom(tableGrob(numwindows, rows=NULL)) +
      theme(panel.grid.major = element_blank(),
            panel.background = element_blank(),
            legend.key.size = unit(1, 'cm'),
            legend.text = element_text(size = 14))
    
    #Suppress NA warning because of NA values in profileplot 
    #(when calculating mean for consecutive bins)
    suppressWarnings(singlecellplot[[i1]] <- cowplot::plot_grid(
      plotlist = list(cowplot::plot_grid(plotlist = list(somydensity, libsizeplot, tableplot), nrow = 1),
                      profileplot, somyplot), ncol = 1))
  }

  #Save results as pdf
  pdf(plot_path, width = plot_width, height = plot_height)
  for(scp in singlecellplot){
    grid::grid.draw(scp)
  }
  dev.off()
}